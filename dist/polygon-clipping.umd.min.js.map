{"version":3,"file":"polygon-clipping.umd.min.js","sources":["../src/bbox.js","../src/flp.js","../src/vector.js","../src/rounder.js","../src/clean-input.js","../src/sweep-event.js","../src/segment.js","../src/geom-in.js","../src/geom-out.js","../src/sweep-line.js","../src/operation.js","../src/index.js"],"sourcesContent":["/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\n\nexport const isInBbox = (bbox, point) => {\n  return (\n    (bbox.ll.x <= point.x) &&\n    (point.x <= bbox.ur.x) &&\n    (bbox.ll.y <= point.y) &&\n    (point.y <= bbox.ur.y)\n  )\n}\n\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\nexport const getBboxOverlap = (b1, b2) => {\n  // check if the bboxes overlap at all\n  if (\n    b2.ur.x < b1.ll.x ||\n    b1.ur.x < b2.ll.x ||\n    b2.ur.y < b1.ll.y ||\n    b1.ur.y < b2.ll.y\n  ) return null\n\n  // find the middle two X values\n  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x\n  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x\n\n  // find the middle two Y values\n  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y\n  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y\n\n  // put those middle values together to get the overlap\n  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } }\n}\n","/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\n\nlet epsilon = Number.EPSILON\n\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52)\n\nconst EPSILON_SQ = epsilon * epsilon\n\n/* FLP comparator */\nexport const cmp = (a, b) => {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0\n    }\n  }\n\n  // check if one is positive and the other negative\n  if (a < 0 && 0 < b) return -1\n  if (b < 0 && 0 < a) return 1\n\n  // check if they're flp equal\n  const ab = a - b\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0\n  }\n\n  // normal comparison\n  return a < b ? -1 : 1\n}\n","import { cmp } from './flp'\n\n/* Cross Product of two vectors with first point at origin */\nexport const crossProduct = (a, b) => a.x * b.y - a.y * b.x\n\n/* Dot Product of two vectors with first point at origin */\nexport const dotProduct = (a, b) => a.x * b.x + a.y * b.y\n\n/* Comparator for two vectors with same starting point */\nexport const compareVectorAngles = (basePt, endPt1, endPt2) => {\n  const v1 = { x: endPt1.x - basePt.x, y: endPt1.y - basePt.y }\n  const v2 = { x: endPt2.x - basePt.x, y: endPt2.y - basePt.y }\n  const kross = crossProduct(v1, v2)\n  return cmp(kross, 0)\n}\n\nexport const length = v => Math.sqrt(dotProduct(v, v))\n\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\nexport const sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y }\n  const vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y }\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase)\n}\n\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\nexport const cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y }\n  const vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y }\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase)\n}\n\n/* Get the closest point on an line (defined by two points)\n * to another point. */\nexport const closestPoint = (ptA1, ptA2, ptB) => {\n  if (ptA1.x === ptA2.x) return { x: ptA1.x, y: ptB.y } // vertical vector\n  if (ptA1.y === ptA2.y) return { x: ptB.x, y: ptA1.y } // horizontal vector\n\n  // determinne which point is further away\n  // we use the further point as our base in the calculation, so that the\n  // vectors are more parallel, providing more accurate dot product\n  const v1 = { x: ptB.x - ptA1.x, y: ptB.y - ptA1.y }\n  const v2 = { x: ptB.x - ptA2.x, y: ptB.y - ptA2.y }\n  let vFar, vA, farPt\n  if (dotProduct(v1, v1) > dotProduct(v2, v2)) {\n    vFar = v1\n    vA = { x: ptA2.x - ptA1.x, y: ptA2.y - ptA1.y }\n    farPt = ptA1\n  }\n  else {\n    vFar = v2\n    vA = { x: ptA1.x - ptA2.x, y: ptA1.y - ptA2.y }\n    farPt = ptA2\n  }\n\n  const dist = dotProduct(vA, vFar) / dotProduct(vA, vA)\n  return { x: farPt.x + dist * vA.x, y: farPt.y + dist * vA.y }\n}\n\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const horizontalIntersection = (pt, v, y) => {\n  if (v.y === 0) return null\n  return { x: pt.x + v.x / v.y * ( y - pt.y ), y: y }\n}\n\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const verticalIntersection = (pt, v, x) => {\n  if (v.x === 0) return null\n  return { x: x, y: pt.y + v.y / v.x * ( x - pt.x ) }\n}\n\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const intersection = (pt1, v1, pt2, v2) => {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x)\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x)\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y)\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y)\n\n  // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  const kross = crossProduct(v1, v2)\n  if (kross == 0) return null\n\n  const ve = { x: pt2.x - pt1.x, y: pt2.y - pt1.y }\n  const d1 = crossProduct(ve, v1) / kross\n  const d2 = crossProduct(ve, v2) / kross\n\n  // take the average of the two calculations to minimize rounding error\n  const x1 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x\n  const y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y\n  const x = (x1 + x2) / 2\n  const y = (y1 + y2) / 2\n  return { x: x, y: y }\n}\n\n/* Given a vector, return one that is perpendicular */\nexport const perpendicular = (v) => {\n  return { x: -v.y, y: v.x }\n}\n","import { cmp } from './flp'\nimport SplayTree from 'splaytree'\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nclass PtRounder {\n  constructor () {\n    this.reset()\n  }\n\n  reset () {\n    this.xRounder = new CoordRounder()\n    this.yRounder = new CoordRounder()\n  }\n\n  round (x, y) {\n    return {\n      x: this.xRounder.round(x),\n      y: this.yRounder.round(y),\n    }\n  }\n}\n\nclass CoordRounder {\n  constructor () {\n    this.tree = new SplayTree()\n    // preseed with 0 so we don't end up with values < Number.EPSILON\n    this.round(0)\n  }\n\n  // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n  round (coord) {\n    const node = this.tree.add(coord)\n\n    const prevNode = this.tree.prev(node)\n    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n      this.tree.remove(coord)\n      return prevNode.key\n    }\n\n    const nextNode = this.tree.next(node)\n    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n      this.tree.remove(coord)\n      return nextNode.key\n    }\n\n    return coord\n  }\n}\n\n// singleton available by import\nconst rounder = new PtRounder()\n\nexport default rounder\n","import { compareVectorAngles } from './vector'\nimport rounder from './rounder'\n\n/* Given input geometry as a standard array-of-arrays geojson-style\n * geometry, return one that uses objects as points, for better perf */\nexport const pointsAsObjects = geom => {\n  // we can handle well-formed multipolys and polys\n  const output = []\n  if (!Array.isArray(geom)) {\n    throw new Error('Input is not a Polygon or MultiPolygon')\n  }\n  for (let i = 0, iMax = geom.length; i < iMax; i++) {\n    if (!Array.isArray(geom[i]) || geom[i].length == 0) {\n      throw new Error('Input is not a Polygon or MultiPolygon')\n    }\n    output.push([])\n    for (let j = 0, jMax = geom[i].length; j < jMax; j++) {\n      if (!Array.isArray(geom[i][j]) || geom[i][j].length == 0) {\n        throw new Error('Input is not a Polygon or MultiPolygon')\n      }\n      if (Array.isArray(geom[i][j][0])) { // multipolygon\n        output[i].push([])\n        for (let k = 0, kMax = geom[i][j].length; k < kMax; k++) {\n          if (!Array.isArray(geom[i][j][k]) || geom[i][j][k].length < 2) {\n            throw new Error('Input is not a Polygon or MultiPolygon')\n          }\n          if (geom[i][j][k].length > 2) {\n            throw new Error(\n              'Input has more than two coordinates. ' +\n              'Only 2-dimensional polygons supported.'\n            )\n          }\n          output[i][j].push(rounder.round(geom[i][j][k][0], geom[i][j][k][1]))\n        }\n      } else { // polygon\n        if (geom[i][j].length < 2) {\n          throw new Error('Input is not a Polygon or MultiPolygon')\n        }\n        if (geom[i][j].length > 2) {\n          throw new Error(\n            'Input has more than two coordinates. ' +\n            'Only 2-dimensional polygons supported.'\n          )\n        }\n        output[i].push(rounder.round(geom[i][j][0], geom[i][j][1]))\n      }\n    }\n  }\n  return output\n}\n\n/* WARN: input modified directly */\nexport const forceMultiPoly = geom => {\n  if (Array.isArray(geom)) {\n    if (geom.length === 0) return // allow empty multipolys\n\n    if (Array.isArray(geom[0])) {\n      if (Array.isArray(geom[0][0])) {\n        if (\n          typeof geom[0][0][0].x === 'number' &&\n          typeof geom[0][0][0].y === 'number'\n        ) {\n          // multipolygon\n          return\n        }\n      }\n      if (\n        typeof geom[0][0].x === 'number' &&\n        typeof geom[0][0].y === 'number'\n      ) {\n        // polygon\n        geom.unshift(geom.splice(0))\n        return\n      }\n    }\n  }\n  throw new Error('Unrecognized input - not a polygon nor multipolygon')\n}\n\n/* WARN: input modified directly */\nexport const cleanMultiPoly = multipoly => {\n  let i = 0\n  while (i < multipoly.length) {\n    const poly = multipoly[i]\n    if (poly.length === 0) {\n      multipoly.splice(i, 1)\n      continue\n    }\n\n    const exteriorRing = poly[0]\n    cleanRing(exteriorRing)\n    // poly is dropped if exteriorRing is degenerate\n    if (exteriorRing.length === 0) {\n      multipoly.splice(i, 1)\n      continue\n    }\n\n    let j = 1\n    while (j < poly.length) {\n      const interiorRing = poly[j]\n      cleanRing(interiorRing)\n      if (interiorRing.length === 0) poly.splice(j, 1)\n      else j++\n    }\n\n    i++\n  }\n}\n\n/* Clean ring:\n *  - remove duplicate points\n *  - remove colinear points\n *  - remove rings with no area (less than 3 distinct points)\n *  - un-close rings (last point should not repeat first)\n *\n * WARN: input modified directly */\nexport const cleanRing = ring => {\n  if (ring.length === 0) return\n  const firstPt = ring[0]\n  const lastPt = ring[ring.length - 1]\n  if (firstPt.x === lastPt.x && firstPt.y === lastPt.y) ring.pop()\n\n  const isPointUncessary = (prevPt, pt, nextPt) =>\n    (prevPt.x === pt.x && prevPt.y === pt.y) ||\n    (nextPt.x === pt.x && nextPt.y === pt.y) ||\n    compareVectorAngles(pt, prevPt, nextPt) === 0\n\n  let i = 0\n  let prevPt, nextPt\n  while (i < ring.length) {\n    prevPt = (i === 0 ? ring[ring.length - 1] : ring[i - 1])\n    nextPt = (i === ring.length - 1 ? ring[0] : ring[i + 1])\n    if (isPointUncessary(prevPt, ring[i], nextPt)) ring.splice(i, 1)\n    else i++\n  }\n\n  // if our ring has less than 3 distinct points now (so is degenerate)\n  // shrink it down to the empty array to communicate to our caller to\n  // drop it\n  while (ring.length < 3 && ring.length > 0) ring.pop()\n}\n","import Segment from './segment'\nimport { cosineOfAngle, sineOfAngle } from './vector'\n\nexport default class SweepEvent {\n\n  // for ordering sweep events in the sweep event queue\n  static compare (a, b) {\n\n    // favor event with a point that the sweep line hits first\n    const ptCmp = SweepEvent.comparePoints(a.point, b.point)\n    if (ptCmp !== 0) return ptCmp\n\n    // the points are the same, so link them if needed\n    if (a.point !== b.point) a.link(b)\n\n    // favor right events over left\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1\n\n    // we have two matching left or right endpoints\n    // ordering of this case is the same as for their segments\n    return Segment.compare(a.segment, b.segment)\n  }\n\n  // for ordering points in sweep line order\n  static comparePoints (aPt, bPt) {\n    if (aPt.x < bPt.x) return -1\n    if (aPt.x > bPt.x) return 1\n\n    if (aPt.y < bPt.y) return -1\n    if (aPt.y > bPt.y) return 1\n\n    return 0\n  }\n\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor (point, isLeft) {\n    if (point.events === undefined) point.events = [this]\n    else point.events.push(this)\n    this.point = point\n    this.isLeft = isLeft\n    // this.segment, this.otherSE set by factory\n  }\n\n  link (other) {\n    if (other.point === this.point) {\n      throw new Error('Tried to link already linked events')\n    }\n    const otherEvents = other.point.events\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i]\n      this.point.events.push(evt)\n      evt.point = this.point\n    }\n    this.checkForConsuming()\n  }\n\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming () {\n    // FIXME: The loops in this method run O(n^2) => no good.\n    //        Maintain little ordered sweep event trees?\n    //        Can we maintaining an ordering that avoids the need\n    //        for the re-sorting with getLeftmostComparator in geom-out?\n\n    // Compare each pair of events to see if other events also match\n    const numEvents = this.point.events.length\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i]\n      if (evt1.segment.consumedBy !== undefined) continue\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j]\n        if (evt2.consumedBy !== undefined) continue\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue\n        evt1.segment.consume(evt2.segment)\n      }\n    }\n  }\n\n  getAvailableLinkedEvents () {\n    // point.events is always of length 2 or greater\n    const events = []\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i]\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt)\n      }\n    }\n    return events\n  }\n\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator (baseEvent) {\n    const cache = new Map()\n\n    const fillCache = linkedEvent => {\n      const nextEvent = linkedEvent.otherSE\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      })\n    }\n\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a)\n      if (!cache.has(b)) fillCache(b)\n\n      const { sine: asine, cosine: acosine } = cache.get(a)\n      const { sine: bsine, cosine: bcosine } = cache.get(b)\n\n      // both on or above x-axis\n      if (asine >= 0 && bsine >= 0) {\n        if (acosine < bcosine) return 1\n        if (acosine > bcosine) return -1\n        return 0\n      }\n\n      // both below x-axis\n      if (asine < 0 && bsine < 0) {\n        if (acosine < bcosine) return -1\n        if (acosine > bcosine) return 1\n        return 0\n      }\n\n      // one above x-axis, one below\n      if (bsine < asine) return -1\n      if (bsine > asine) return 1\n      return 0\n    }\n  }\n}\n","import operation from './operation'\nimport SweepEvent from './sweep-event'\nimport { isInBbox, getBboxOverlap } from './bbox'\nimport { cmp } from './flp'\nimport { closestPoint, intersection } from './vector'\nimport rounder from './rounder'\n\n// Give segments unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nlet segmentId = 0\n\nexport default class Segment {\n\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare (a, b) {\n\n    const alx = a.leftSE.point.x\n    const blx = b.leftSE.point.x\n    const arx = a.rightSE.point.x\n    const brx = b.rightSE.point.x\n\n    // check if they're even in the same vertical plane\n    if (brx < alx) return 1\n    if (arx < blx) return -1\n\n    const aly = a.leftSE.point.y\n    const bly = b.leftSE.point.y\n    const ary = a.rightSE.point.y\n    const bry = b.rightSE.point.y\n\n    // is left endpoint of segment B the right-more?\n    if (alx < blx) {\n      // are the two segments in the same horizontal plane?\n      if (bly < aly && bly < ary) return 1\n      if (bly > aly && bly > ary) return -1\n\n      // is the B left endpoint colinear to segment A?\n      const aCmpBLeft = a.comparePoint(b.leftSE.point)\n      if (aCmpBLeft < 0) return 1\n      if (aCmpBLeft > 0) return -1\n\n      // is the A right endpoint colinear to segment B ?\n      const bCmpARight = b.comparePoint(a.rightSE.point)\n      if (bCmpARight !== 0) return bCmpARight\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return -1\n    }\n\n    // is left endpoint of segment A the right-more?\n    if (alx > blx) {\n      if (aly < bly && aly < bry) return -1\n      if (aly > bly && aly > bry) return 1\n\n      // is the A left endpoint colinear to segment B?\n      const bCmpALeft = b.comparePoint(a.leftSE.point)\n      if (bCmpALeft !== 0) return bCmpALeft\n\n      // is the B right endpoint colinear to segment A?\n      const aCmpBRight = a.comparePoint(b.rightSE.point)\n      if (aCmpBRight < 0) return 1\n      if (aCmpBRight > 0) return -1\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return 1\n    }\n\n    // if we get here, the two left endpoints are in the same\n    // vertical plane, ie alx === blx\n\n    // consider the lower left-endpoint to come first\n    if (aly < bly) return -1\n    if (aly > bly) return 1\n\n    // left endpoints are identical\n    // check for colinearity by using the left-more right endpoint\n\n    // is the A right endpoint more left-more?\n    if (arx < brx) {\n      const bCmpARight = b.comparePoint(a.rightSE.point)\n      if (bCmpARight !== 0) return bCmpARight\n    }\n\n    // is the B right endpoint more left-more?\n    if (arx > brx) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point)\n      if (aCmpBRight < 0) return 1\n      if (aCmpBRight > 0) return -1\n    }\n\n    if (arx !== brx)  {\n      // are these two [almost] vertical segments with opposite orientation?\n      // if so, the one with the lower right endpoint comes first\n      const ay = ary - aly\n      const ax = arx - alx\n      const by = bry - bly\n      const bx = brx - blx\n      if (ay > ax && by < bx) return 1\n      if (ay < ax && by > bx) return -1\n    }\n\n    // we have colinear segments with matching orientation\n    // consider the one with more left-more right endpoint to be first\n    if (arx > brx) return 1\n    if (arx < brx) return -1\n\n    // if we get here, two two right endpoints are in the same\n    // vertical plane, ie arx === brx\n\n    // consider the lower right-endpoint to come first\n    if (ary < bry) return -1\n    if (ary > bry) return 1\n\n    // right endpoints identical as well, so the segments are idential\n    // fall back on creation order as consistent tie-breaker\n    if (a.id < b.id) return -1\n    if (a.id > b.id) return 1\n\n    // identical segment, ie a === b\n    return 0\n  }\n\n  /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */\n  constructor (leftSE, rightSE, rings, windings) {\n    this.id = ++segmentId\n    this.leftSE = leftSE\n    leftSE.segment = this\n    leftSE.otherSE = rightSE\n    this.rightSE = rightSE\n    rightSE.segment = this\n    rightSE.otherSE = leftSE\n    this.rings = rings\n    this.windings = windings\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt, winding\n\n    // ordering the two points according to sweep line ordering\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2)\n    if (cmpPts < 0) {\n      leftPt = pt1\n      rightPt = pt2\n      winding = 1\n    }\n    else if (cmpPts > 0) {\n      leftPt = pt2\n      rightPt = pt1\n      winding = -1\n    }\n    else throw new Error(\n      `Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`\n    )\n\n    const leftSE = new SweepEvent(leftPt, true)\n    const rightSE = new SweepEvent(rightPt, false)\n    return new Segment(leftSE, rightSE, [ring], [winding])\n  }\n\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE (newRightSE) {\n    this.rightSE = newRightSE\n    this.rightSE.segment = this\n    this.rightSE.otherSE = this.leftSE\n    this.leftSE.otherSE = this.rightSE\n  }\n\n  bbox () {\n    const y1 = this.leftSE.point.y\n    const y2 = this.rightSE.point.y\n    return {\n      ll: { x: this.leftSE.point.x, y: y1 < y2 ? y1 : y2 },\n      ur: { x: this.rightSE.point.x, y: y1 > y2 ? y1 : y2 }\n    }\n  }\n\n  /* A vector from the left point to the right */\n  vector () {\n    return {\n      x: this.rightSE.point.x - this.leftSE.point.x,\n      y: this.rightSE.point.y - this.leftSE.point.y\n    }\n  }\n\n  isAnEndpoint (pt) {\n    return (\n      (pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y) ||\n      (pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y)\n    )\n  }\n\n  /* Compare this segment with a point. Return value indicates:\n   *     1: point lies above or to the left of segment\n   *     0: point is colinear to segment\n   *    -1: point is below or to the right of segment */\n  comparePoint (point) {\n    if (this.isAnEndpoint(point)) return 0\n    const interPt = closestPoint(this.leftSE.point, this.rightSE.point, point)\n\n    // use cmp() to do the same rounding as would apply in rounder.round\n    // but avoid using rounder.round for performance boost, and to avoid\n    // saving the result in the rounding trees\n\n    // also, there is a fair amount of rounding error introduced when computing\n    // the closestPoint to a nearly vertical or horizontal segment. Thus, we use\n    // the more accurate coordinate for comparison of the two points\n\n    const lx = this.leftSE.point.x\n    const ly = this.leftSE.point.y\n    const rx = this.rightSE.point.x\n    const ry = this.rightSE.point.y\n\n    // is the segment upward sloping?\n    if (ry >= ly) {\n      // is the segment more vertical?\n      if (ry - ly > rx - lx) {\n        // use the X coordinate\n        const cmpX = cmp(interPt.x, point.x)\n        if (cmpX != 0) return cmpX\n      }\n      else {\n        // segment is more horizontal, so use Y coord\n        const cmpY = cmp(point.y, interPt.y)\n        if (cmpY != 0) return cmpY\n      }\n    }\n    else {\n      // segment is more downward sloping\n      // is the segment more vertical?\n      if (ly - ry > rx - lx) {\n        // use the X coordinate\n        const cmpX = cmp(point.x, interPt.x)\n        if (cmpX != 0) return cmpX\n      }\n      else {\n        // segment is more horizontal, so use the Y coordinate\n        const cmpY = cmp(point.y, interPt.y)\n        if (cmpY != 0) return cmpY\n      }\n    }\n\n    // on the line\n    return 0\n  }\n\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection (other) {\n    // If bboxes don't overlap, there can't be any intersections\n    const tBbox = this.bbox()\n    const oBbox = other.bbox()\n    const bboxOverlap = getBboxOverlap(tBbox, oBbox)\n    if (bboxOverlap === null) return null\n\n    // We first check to see if the endpoints can be considered intersections.\n    // This will 'snap' intersections to endpoints if possible, and will\n    // handle cases of colinearity.\n\n    const tlp = this.leftSE.point\n    const trp = this.rightSE.point\n    const olp = other.leftSE.point\n    const orp = other.rightSE.point\n\n    // does each endpoint touch the other segment?\n    // note that we restrict the 'touching' definition to only allow segments\n    // to touch endpoints that lie forward from where we are in the sweep line pass\n    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0\n    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0\n    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0\n    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0\n\n    // do left endpoints match?\n    if (touchesThisLSE && touchesOtherLSE) {\n      // these two cases are for colinear segments with matching left\n      // endpoints, and one segment being longer than the other\n      if (touchesThisRSE && !touchesOtherRSE) return trp\n      if (!touchesThisRSE && touchesOtherRSE) return orp\n      // either the two segments match exactly (two trival intersections)\n      // or just on their left endpoint (one trivial intersection\n      return null\n    }\n\n    // does this left endpoint matches (other doesn't)\n    if (touchesThisLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesOtherRSE) {\n        if (tlp.x === orp.x && tlp.y === orp.y) return null\n      }\n      // t-intersection on left endpoint\n      return tlp\n    }\n\n    // does other left endpoint matches (this doesn't)\n    if (touchesOtherLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesThisRSE) {\n        if (trp.x === olp.x && trp.y === olp.y) return null\n      }\n      // t-intersection on left endpoint\n      return olp\n    }\n\n    // trivial intersection on right endpoints\n    if (touchesThisRSE && touchesOtherRSE) return null\n\n    // t-intersections on just one right endpoint\n    if (touchesThisRSE) return trp\n    if (touchesOtherRSE) return orp\n\n    // None of our endpoints intersect. Look for a general intersection between\n    // infinite lines laid over the segments\n    const pt = intersection(tlp, this.vector(), olp, other.vector())\n\n    // are the segments parrallel? Note that if they were colinear with overlap,\n    // they would have an endpoint intersection and that case was already handled above\n    if (pt === null) return null\n\n    // is the intersection found between the lines not on the segments?\n    if (!isInBbox(bboxOverlap, pt)) return null\n\n    // round the the computed point if needed\n    return rounder.round(pt.x, pt.y)\n  }\n\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split (point) {\n    const newEvents = []\n    const alreadyLinked = point.events !== undefined\n\n    const newLeftSE = new SweepEvent(point, true)\n    const newRightSE = new SweepEvent(point, false)\n    const oldRightSE = this.rightSE\n    this.replaceRightSE(newRightSE)\n    newEvents.push(newRightSE)\n    newEvents.push(newLeftSE)\n    const newSeg = new Segment(\n      newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()\n    )\n\n    // when splitting a nearly vertical downward-facing segment,\n    // sometimes one of the resulting new segments is vertical, in which\n    // case its left and right events may need to be swapped\n    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n      newSeg.swapEvents()\n    }\n    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n      this.swapEvents()\n    }\n\n    // in the point we just used to create new sweep events with was already\n    // linked to other events, we need to check if either of the affected\n    // segments should be consumed\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming()\n      newRightSE.checkForConsuming()\n    }\n\n    return newEvents\n  }\n\n  /* Swap which event is left and right */\n  swapEvents () {\n    const tmpEvt = this.rightSE\n    this.rightSE = this.leftSE\n    this.leftSE = tmpEvt\n    this.leftSE.isLeft = true\n    this.rightSE.isLeft = false\n    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n      this.windings[i] *= -1\n    }\n  }\n\n  /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume (other) {\n    let consumer = this\n    let consumee = other\n    while (consumer.consumedBy) consumer = consumer.consumedBy\n    while (consumee.consumedBy) consumee = consumee.consumedBy\n\n    const cmp = Segment.compare(consumer, consumee)\n    if (cmp === 0) return  // already consumed\n    // the winner of the consumption is the earlier segment\n    // according to sweep line ordering\n    if (cmp  > 0) {\n      const tmp = consumer\n      consumer = consumee\n      consumee = tmp\n    }\n\n    // make sure a segment doesn't consume it's prev\n    if (consumer.prev === consumee) {\n      const tmp = consumer\n      consumer = consumee\n      consumee = tmp\n    }\n\n    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n      const ring = consumee.rings[i]\n      const winding = consumee.windings[i]\n      const index = consumer.rings.indexOf(ring)\n      if (index === -1) {\n        consumer.rings.push(ring)\n        consumer.windings.push(winding)\n      }\n      else consumer.windings[index] += winding\n    }\n    consumee.rings = null\n    consumee.windings = null\n    consumee.consumedBy = consumer\n\n    // mark sweep events consumed as to maintain ordering in sweep event queue\n    consumee.leftSE.consumedBy = consumer.leftSE\n    consumee.rightSE.consumedBy = consumer.rightSE\n  }\n\n  /* The first segment previous segment chain that is in the result */\n  prevInResult () {\n    if (this._prevInResult !== undefined) return this._prevInResult\n    if (! this.prev) this._prevInResult = null\n    else if (this.prev.isInResult()) this._prevInResult = this.prev\n    else this._prevInResult = this.prev.prevInResult()\n    return this._prevInResult\n  }\n\n  beforeState() {\n    if (this._beforeState !== undefined) return this._beforeState\n    if (! this.prev) this._beforeState = {\n      rings: [],\n      windings: [],\n      multiPolys: [],\n    }\n    else {\n      const seg = this.prev.consumedBy || this.prev\n      this._beforeState = seg.afterState()\n    }\n    return this._beforeState\n  }\n\n  afterState () {\n    if (this._afterState !== undefined) return this._afterState\n\n    const beforeState = this.beforeState()\n    this._afterState = {\n      rings: beforeState.rings.slice(0),\n      windings: beforeState.windings.slice(0),\n      multiPolys: []\n    }\n    const ringsAfter = this._afterState.rings\n    const windingsAfter = this._afterState.windings\n    const mpsAfter = this._afterState.multiPolys\n\n    // calculate ringsAfter, windingsAfter\n    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n      const ring = this.rings[i]\n      const winding = this.windings[i]\n      const index = ringsAfter.indexOf(ring)\n      if (index === -1) {\n        ringsAfter.push(ring)\n        windingsAfter.push(winding)\n      }\n      else windingsAfter[index] += winding\n    }\n\n    // calcualte polysAfter\n    const polysAfter = []\n    const polysExclude = []\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      if (windingsAfter[i] === 0) continue // non-zero rule\n      const ring = ringsAfter[i]\n      const poly = ring.poly\n      if (polysExclude.indexOf(poly) !== -1) continue\n      if (ring.isExterior) polysAfter.push(poly)\n      else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly)\n        const index = polysAfter.indexOf(ring.poly)\n        if (index !== -1) polysAfter.splice(index, 1)\n      }\n    }\n\n    // calculate multiPolysAfter\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly\n      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp)\n    }\n\n    return this._afterState\n  }\n\n  /* Is this segment part of the final result? */\n  isInResult () {\n    // if we've been consumed, we're not in the result\n    if (this.consumedBy) return false\n\n    if (this._isInResult !== undefined) return this._isInResult\n\n    const mpsBefore = this.beforeState().multiPolys\n    const mpsAfter = this.afterState().multiPolys\n\n    switch (operation.type) {\n      case 'union': {\n        // UNION - included iff:\n        //  * On one side of us there is 0 poly interiors AND\n        //  * On the other side there is 1 or more.\n        const noBefores = mpsBefore.length === 0\n        const noAfters = mpsAfter.length === 0\n        this._isInResult = noBefores !== noAfters\n        break\n      }\n\n      case 'intersection': {\n        // INTERSECTION - included iff:\n        //  * on one side of us all multipolys are rep. with poly interiors AND\n        //  * on the other side of us, not all multipolys are repsented\n        //    with poly interiors\n        let least\n        let most\n        if (mpsBefore.length < mpsAfter.length) {\n          least = mpsBefore.length\n          most = mpsAfter.length\n        } else {\n          least = mpsAfter.length\n          most = mpsBefore.length\n        }\n        this._isInResult = most === operation.numMultiPolys && least < most\n        break\n      }\n\n      case 'xor': {\n        // XOR - included iff:\n        //  * the difference between the number of multipolys represented\n        //    with poly interiors on our two sides is an odd number\n        const diff = Math.abs(mpsBefore.length - mpsAfter.length)\n        this._isInResult = diff % 2 === 1\n        break\n      }\n\n      case 'difference': {\n        // DIFFERENCE included iff:\n        //  * on exactly one side, we have just the subject\n        const isJustSubject = mps => mps.length === 1 && mps[0].isSubject\n        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter)\n        break\n      }\n\n      default:\n        throw new Error(`Unrecognized operation type found ${operation.type}`)\n    }\n\n    return this._isInResult\n  }\n\n}\n","import Segment from './segment'\n\nexport class RingIn {\n  constructor (geomRing, poly, isExterior) {\n    this.poly = poly\n    this.isExterior = isExterior\n    this.segments = []\n\n    let prevPoint = geomRing[0]\n    this.bbox = {\n      ll: { x: prevPoint.x, y: prevPoint.y },\n      ur: { x: prevPoint.x, y: prevPoint.y },\n    }\n\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      let point = geomRing[i]\n      this.segments.push(Segment.fromRing(prevPoint, point, this))\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y\n      prevPoint = point\n    }\n    this.segments.push(Segment.fromRing(prevPoint, geomRing[0], this))\n  }\n\n  getSweepEvents () {\n    const sweepEvents = []\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i]\n      sweepEvents.push(segment.leftSE)\n      sweepEvents.push(segment.rightSE)\n    }\n    return sweepEvents\n  }\n}\n\nexport class PolyIn {\n  constructor (geomPoly, multiPoly) {\n    this.exteriorRing = new RingIn(geomPoly[0], this, true)\n    // copy by value\n    this.bbox = {\n      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },\n      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y },\n    }\n    this.interiorRings = []\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      const ring = new RingIn(geomPoly[i], this, false)\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y\n      this.interiorRings.push(ring)\n    }\n    this.multiPoly = multiPoly\n  }\n\n  getSweepEvents () {\n    const sweepEvents = this.exteriorRing.getSweepEvents()\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents()\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j])\n      }\n    }\n    return sweepEvents\n  }\n}\n\nexport class MultiPolyIn {\n  constructor (geomMultiPoly) {\n    this.polys = []\n    this.bbox = {\n      ll: { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY },\n      ur: { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY },\n    }\n    for (let i = 0, iMax = geomMultiPoly.length; i < iMax; i++) {\n      const poly = new PolyIn(geomMultiPoly[i], this)\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y\n      this.polys.push(poly)\n    }\n    this.isSubject = false\n  }\n\n  markAsSubject () {\n    this.isSubject = true\n  }\n\n  getSweepEvents () {\n    const sweepEvents = []\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents()\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j])\n      }\n    }\n    return sweepEvents\n  }\n}\n","import { compareVectorAngles } from './vector'\nimport SweepEvent from './sweep-event'\n\nexport class RingOut {\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory (allSegments) {\n    const ringsOut = []\n\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i]\n      if (!segment.isInResult() || segment.ringOut) continue\n\n      let prevEvent = null\n      let event = segment.leftSE\n      let nextEvent = segment.rightSE\n      const events = [event]\n\n      const startingPoint = event.point\n      const intersectionLEs = []\n\n      /* Walk the chain of linked events to form a closed ring */\n      while (true) {\n        prevEvent = event\n        event = nextEvent\n        events.push(event)\n\n        /* Is the ring complete? */\n        if (event.point === startingPoint) break\n\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents()\n\n          /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n           * part of the algorithm malfunctioned... please file a bug report. */\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point\n            const lastPt = events[events.length - 1].point\n            throw new Error(\n              `Unable to complete output ring starting at [${firstPt.x},` +\n                ` ${firstPt.y}]. Last matching segment found ends at` +\n                ` [${lastPt.x}, ${lastPt.y}].`\n            )\n          }\n\n          /* Only one way to go, so cotinue on the path */\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE\n            break\n          }\n\n          /* We must have an intersection. Check for a completed loop */\n          let indexLE = null\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j\n              break\n            }\n          }\n          /* Found a completed loop. Cut that off and make a ring */\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0]\n            const ringEvents = events.splice(intersectionLE.index)\n            ringEvents.unshift(ringEvents[0].otherSE)\n            ringsOut.push(new RingOut(ringEvents.reverse()))\n            continue\n          }\n          /* register the intersection */\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point,\n          })\n          /* Choose the left-most option to continue the walk */\n          const comparator = event.getLeftmostComparator(prevEvent)\n          nextEvent = availableLEs.sort(comparator)[0].otherSE\n          break\n        }\n      }\n\n      ringsOut.push(new RingOut(events))\n    }\n    return ringsOut\n  }\n\n  constructor (events) {\n    this.events = events\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this\n    }\n    this.poly = null\n  }\n\n  getGeom () {\n    // Remove superfluous points (ie extra points along a straight line),\n    let prevPt = this.events[0].point\n    const points = [prevPt]\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt = this.events[i].point\n      const nextPt = this.events[i + 1].point\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue\n      points.push(pt)\n      prevPt = pt\n    }\n\n    // ring was all (within rounding error of angle calc) colinear points\n    if (points.length === 1) return null\n\n    // check if the starting point is necessary\n    const pt = points[0]\n    const nextPt = points[1]\n    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift()\n\n    points.push(points[0])\n    const step = this.isExteriorRing() ? 1 : -1\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1\n    const iEnd = this.isExteriorRing() ? points.length : -1\n    const orderedPoints = []\n    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y])\n    return orderedPoints\n  }\n\n  isExteriorRing () {\n    if (this._isExteriorRing === undefined) {\n      const enclosing = this.enclosingRing()\n      this._isExteriorRing = enclosing ? ! enclosing.isExteriorRing() : true\n    }\n    return this._isExteriorRing\n  }\n\n  enclosingRing () {\n    if (this._enclosingRing === undefined) {\n      this._enclosingRing = this._calcEnclosingRing()\n    }\n    return this._enclosingRing\n  }\n\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing () {\n    // start with the ealier sweep line event so that the prevSeg\n    // chain doesn't lead us inside of a loop of ours\n    let leftMostEvt = this.events[0]\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i]\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt\n    }\n\n    let prevSeg = leftMostEvt.segment.prevInResult()\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null\n\n    while (true) {\n      // no segment found, thus no ring can enclose us\n      if (!prevSeg) return null\n\n      // no segments below prev segment found, thus the ring of the prev\n      // segment must loop back around and enclose us\n      if (!prevPrevSeg) return prevSeg.ringOut\n\n      // if the two segments are of different rings, the ring of the prev\n      // segment must either loop around us or the ring of the prev prev\n      // seg, which would make us and the ring of the prev peers\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut\n        } else return prevSeg.ringOut.enclosingRing()\n      }\n\n      // two segments are from the same ring, so this was a penisula\n      // of that ring. iterate downward, keep searching\n      prevSeg = prevPrevSeg.prevInResult()\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null\n    }\n  }\n}\n\nexport class PolyOut {\n  constructor (exteriorRing) {\n    this.exteriorRing = exteriorRing\n    exteriorRing.poly = this\n    this.interiorRings = []\n  }\n\n  addInterior (ring) {\n    this.interiorRings.push(ring)\n    ring.poly = this\n  }\n\n  getGeom () {\n    const geom = [this.exteriorRing.getGeom()]\n    // exterior ring was all (within rounding error of angle calc) colinear points\n    if (geom[0] === null) return null\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom()\n      // interior ring was all (within rounding error of angle calc) colinear points\n      if (ringGeom === null) continue\n      geom.push(ringGeom)\n    }\n    return geom\n  }\n}\n\nexport class MultiPolyOut {\n  constructor (rings) {\n    this.rings = rings\n    this.polys = this._composePolys(rings)\n  }\n\n  getGeom () {\n    const geom = []\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom()\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (polyGeom === null) continue\n      geom.push(polyGeom)\n    }\n    return geom\n  }\n\n  _composePolys (rings) {\n    const polys = []\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i]\n      if (ring.poly) continue\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring))\n      else {\n        const enclosingRing = ring.enclosingRing()\n        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing))\n        enclosingRing.poly.addInterior(ring)\n      }\n    }\n    return polys\n  }\n}\n","import SplayTree from 'splaytree'\nimport Segment from './segment'\nimport SweepEvent from './sweep-event'\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nexport default class SweepLine {\n  constructor (queue, comparator = Segment.compare) {\n    this.queue = queue\n    this.tree = new SplayTree(comparator)\n    this.segments = []\n  }\n\n  process (event) {\n    const segment = event.segment\n    const newEvents = []\n\n    // if we've already been consumed by another segment,\n    // clean up our body parts and get out\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.remove(event.otherSE)\n      else this.tree.remove(segment)\n      return newEvents\n    }\n\n    const node = event.isLeft\n      ? this.tree.insert(segment)\n      : this.tree.find(segment)\n\n    if (! node) throw new Error(\n      `Unable to find segment #${segment.id} ` +\n      `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` +\n      `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` +\n      'in SweepLine tree. Please submit a bug report.'\n    )\n\n    let prevNode = node\n    let nextNode = node\n    let prevSeg = undefined\n    let nextSeg = undefined\n\n    // skip consumed segments still in tree\n    while (prevSeg === undefined) {\n      prevNode = this.tree.prev(prevNode)\n      if (prevNode === null) prevSeg = null\n      else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key\n    }\n\n    // skip consumed segments still in tree\n    while (nextSeg === undefined) {\n      nextNode = this.tree.next(nextNode)\n      if (nextNode === null) nextSeg = null\n      else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key\n    }\n\n    if (event.isLeft) {\n\n      // Check for intersections against the previous segment in the sweep line\n      let prevMySplitter = null\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment)\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      // Check for intersections against the next segment in the sweep line\n      let nextMySplitter = null\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment)\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter\n          if (!nextSeg.isAnEndpoint(nextInter))  {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      // For simplicity, even if we find more than one intersection we only\n      // spilt on the 'earliest' (sweep-line style) of the intersections.\n      // The other intersection will be handled in a future process().\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n\n        let mySplitter = null\n        if (prevMySplitter === null) mySplitter = nextMySplitter\n        else if (nextMySplitter === null) mySplitter = prevMySplitter\n        else {\n          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter)\n          if (cmpSplitters < 0) mySplitter = prevMySplitter\n          if (cmpSplitters > 0) mySplitter = nextMySplitter\n          // the two splitters are the exact same point\n          mySplitter = prevMySplitter\n        }\n\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        this.queue.remove(segment.rightSE)\n        newEvents.push(segment.rightSE)\n\n        const newEventsFromSplit = segment.split(mySplitter)\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i])\n        }\n      }\n\n      if (newEvents.length > 0) {\n        // We found some intersections, so re-do the current event to\n        // make sure sweep line ordering is totally consistent for later\n        // use with the segment 'prev' pointers\n        this.tree.remove(segment)\n        newEvents.push(event)\n\n      } else {\n        // done with left event\n        this.segments.push(segment)\n        segment.prev = prevSeg\n      }\n\n    } else {\n      // event.isRight\n\n      // since we're about to be removed from the sweep line, check for\n      // intersections between our previous and next segments\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg)\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter))  {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter))  {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      this.tree.remove(segment)\n    }\n\n    return newEvents\n  }\n\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    // Rounding errors can cause changes in ordering,\n    // so remove afected segments and right sweep events before splitting\n    // removeNode() doesn't work, so have re-find the seg\n    // https://github.com/w8r/splay-tree/pull/5\n    this.tree.remove(seg)\n    const rightSE = seg.rightSE\n    this.queue.remove(rightSE)\n    const newEvents = seg.split(pt)\n    newEvents.push(rightSE)\n    // splitting can trigger consumption\n    if (seg.consumedBy === undefined) this.tree.insert(seg)\n    return newEvents\n  }\n}\n","import SplayTree from 'splaytree'\nimport { getBboxOverlap } from './bbox'\nimport * as cleanInput from './clean-input'\nimport * as geomIn from './geom-in'\nimport * as geomOut from './geom-out'\nimport rounder from './rounder'\nimport SweepEvent from './sweep-event'\nimport SweepLine from './sweep-line'\n\nexport class Operation {\n  run (type, geom, moreGeoms) {\n    operation.type = type\n    rounder.reset()\n\n    /* Make a copy of the input geometry with rounded points as objects */\n    const geoms = [cleanInput.pointsAsObjects(geom)]\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      geoms.push(cleanInput.pointsAsObjects(moreGeoms[i]))\n    }\n\n    /* Clean inputs */\n    for (let i = 0, iMax = geoms.length; i < iMax; i++) {\n      cleanInput.forceMultiPoly(geoms[i])\n      cleanInput.cleanMultiPoly(geoms[i])\n    }\n\n    /* Convert inputs to MultiPoly objects, mark subject */\n    const multipolys = []\n    for (let i = 0, iMax = geoms.length; i < iMax; i++) {\n      multipolys.push(new geomIn.MultiPolyIn(geoms[i]))\n    }\n    multipolys[0].markAsSubject()\n    operation.numMultiPolys = multipolys.length\n\n    /* BBox optimization for difference operation\n     * If the bbox of a multipolygon that's part of the clipping doesn't\n     * intersect the bbox of the subject at all, we can just drop that\n     * multiploygon. */\n    if (operation.type === 'difference') {\n      // in place removal\n      const subject = multipolys[0]\n      let i = 1\n      while (i < multipolys.length) {\n        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++\n        else multipolys.splice(i, 1)\n      }\n    }\n\n    /* BBox optimization for intersection operation\n     * If we can find any pair of multipolygons whose bbox does not overlap,\n     * then the result will be empty. */\n    if (operation.type === 'intersection') {\n      // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n      //       it could be optimized to O(n * ln(n))\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const mpA = multipolys[i]\n        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return []\n        }\n      }\n    }\n\n    /* Put segment endpoints in a priority queue */\n    const queue = new SplayTree(SweepEvent.compare)\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents()\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.insert(sweepEvents[j])\n      }\n    }\n\n    /* Pass the sweep line over those endpoints */\n    const sweepLine = new SweepLine(queue)\n    let prevQueueSize = queue.size\n    let node = queue.pop()\n    while (node) {\n      const evt = node.key\n      if (queue.size === prevQueueSize) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        const seg = evt.segment\n        throw new Error(\n          `Unable to pop() ${evt.isLeft ? 'left' : 'right'} SweepEvent ` +\n          `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` +\n          `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` +\n          `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue. ` +\n          'Please file a bug report.'\n        )\n      }\n      const newEvents = sweepLine.process(evt)\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt = newEvents[i]\n        if (evt.consumedBy === undefined) queue.insert(evt)\n      }\n      prevQueueSize = queue.size\n      node = queue.pop()\n    }\n\n    // free some memory we don't need anymore\n    rounder.reset()\n\n    /* Collect and compile segments we're keeping into a multipolygon */\n    const ringsOut = geomOut.RingOut.factory(sweepLine.segments)\n    const result = new geomOut.MultiPolyOut(ringsOut)\n    return result.getGeom()\n  }\n}\n\n// singleton available by import\nconst operation = new Operation()\n\nexport default operation\n","import operation from './operation'\n\nconst union = (geom, ...moreGeoms) =>\n  operation.run('union', geom, moreGeoms)\n\nconst intersection = (geom, ...moreGeoms) =>\n  operation.run('intersection', geom, moreGeoms)\n\nconst xor = (geom, ...moreGeoms) =>\n  operation.run('xor', geom, moreGeoms)\n\nconst difference = (subjectGeom, ...clippingGeoms) =>\n  operation.run('difference', subjectGeom, clippingGeoms)\n\nexport default {\n  union: union,\n  intersection: intersection,\n  xor: xor,\n  difference: difference,\n}\n"],"names":["isInBbox","bbox","point","ll","x","ur","y","getBboxOverlap","b1","b2","lowerX","upperX","epsilon","Number","EPSILON","undefined","Math","pow","EPSILON_SQ","cmp","a","b","ab","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","v1","v2","kross","length","v","sqrt","cosineOfAngle","pShared","pBase","pAngle","vBase","vAngle","horizontalIntersection","pt","verticalIntersection","PtRounder","reset","xRounder","CoordRounder","yRounder","this","round","tree","SplayTree","coord","node","add","prevNode","prev","key","remove","nextNode","next","rounder","pointsAsObjects","geom","output","Array","isArray","Error","i","iMax","push","j","jMax","k","kMax","forceMultiPoly","unshift","splice","cleanMultiPoly","multipoly","poly","exteriorRing","cleanRing","interiorRing","ring","firstPt","lastPt","pop","prevPt","nextPt","isPointUncessary","SweepEvent","isLeft","events","ptCmp","comparePoints","link","Segment","compare","segment","aPt","bPt","other","otherEvents","evt","checkForConsuming","numEvents","evt1","consumedBy","evt2","otherSE","consume","ringOut","isInResult","baseEvent","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","_this","cosine","has","get","asine","acosine","bsine","bcosine","segmentId","leftSE","rightSE","rings","windings","id","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","ay","ax","by","bx","newRightSE","y1","y2","isAnEndpoint","interPt","ptA1","ptA2","ptB","vFar","vA","farPt","dist","closestPoint","lx","ly","rx","ry","cmpX","cmpY","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","pt1","pt2","ve","d1","d2","intersection","vector","newEvents","alreadyLinked","newLeftSE","oldRightSE","replaceRightSE","newSeg","slice","swapEvents","tmpEvt","consumer","consumee","tmp","winding","index","indexOf","_prevInResult","prevInResult","_beforeState","seg","afterState","multiPolys","_afterState","beforeState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","isExterior","mp","multiPoly","_isInResult","mpsBefore","operation","type","noBefores","noAfters","least","most","numMultiPolys","diff","abs","isJustSubject","mps","isSubject","leftPt","rightPt","cmpPts","RingIn","geomRing","segments","prevPoint","fromRing","sweepEvents","PolyIn","geomPoly","interiorRings","getSweepEvents","ringSweepEvents","MultiPolyIn","geomMultiPoly","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","getAvailableLinkedEvents","indexLE","comparator","getLeftmostComparator","sort","intersectionLE","ringEvents","reverse","points","shift","step","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","getGeom","ringGeom","MultiPolyOut","_composePolys","polyGeom","addInterior","SweepLine","queue","insert","find","nextSeg","prevMySplitter","prevInter","getIntersection","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","mySplitter","cmpSplitters","split","inter","moreGeoms","geoms","cleanInput","multipolys","geomIn","markAsSubject","subject","mpA","sweepLine","prevQueueSize","size","process","geomOut","factory","union","run","xor","difference","subjectGeom","clippingGeoms"],"mappings":"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"}